/**
 * File:	include/openteam/routines.ycp
 * Package:	Configuration of openteam
 * Summary:	Miscelanous functions for configuration of openteam.
 * Authors:	Carsten Hoeger <choeger@suse.de>
 *
 * $Id$
 */

{

textdomain "openteam";

/* FIXME: Remove this file if you do not need it! */

/**
 * Abort function
 * @return blah blah lahjk
 */
global define boolean Abort() ``{
    if(AbortFunction != nil)
	return eval(AbortFunction) == true;
    return false;
}

/**
 * Check for pending Abort press
 * @return true if pending abort
 */
global define boolean PollAbort() ``{
    return UI::PollInput() == `abort;
}

/**
 * If modified, ask for confirmation
 * @return true if abort is confirmed
 */
global define boolean ReallyAbort() ``{
    return !Modified() || UI::ReallyAbortPopup(true);
}

/**
 * Progress::NextStage and Progress::Title combined into one function
 * @param title progressbar title
 */
global define void ProgressNextStage(string title) ``{
    Progress::NextStage();
    Progress::Title(title);
}

    /*
     * adapt /etc/cyrus.conf and /etc/imapd.conf
     * Parameters:
     *
     * NONE
     *
     */
    global define create_cyrusconf(map imapdopts) ``{

	// *********************** imapd.conf *********************************

	string cf = SCR::Read(.target.string, Openteam::imapdconf);
	list cflist = splitstring(cf,"\n");
	
	map imapcnf = $[];
	foreach(`line, cflist, ``{
	    if( regexpmatch(line, ".*:") ) {
		line = deletechars(line, "#");
		list keyval = splitstring(line, ":");
		imapcnf[keyval[0]:""] = normalize(keyval[1]:"");
	    }
	});
	
	foreach(`key, `val, imapdopts, ``{
	    imapcnf[key] = val;
	});
	
	cf = "";
	foreach(`key, `val, imapcnf, ``{
	    //y2milestone("%1 = %2", key, val);
	    cf = cf + key + ": " + val + "\n";
	});
	
	
	SCR::Write (.target.string, Openteam::imapdconf, cf);

	// *********************** cyrus.conf *********************************

	cf = SCR::Read(.target.string, Openteam::cyrusconf);
	cflist = splitstring(cf,"\n");

	integer cnt=0;
	string line = "";
	while( cnt < size(cflist) ) {
	    line = cflist[cnt]:"";
	    if( regexpmatch(line, ".*lmtpunix") ) {
		cflist[cnt] = "  lmtpunix      cmd=\"lmtpd\" listen=\"/var/spool/postfix/public/lmtp\" prefork=0";
	    }
	    cnt = cnt + 1;
	}
	cf = mergestring(cflist, "\n");
	
	SCR::Write (.target.string, Openteam::cyrusconf, cf);
    }
    

    /*
     * cleanup usage of spaces
     */
    global define normalize(string text) ``{
	integer i=0;
	string norm = "";
	while( i<size(text) ) {
	    norm = norm + substring(text,i,1);
	    if( substring(text,i,1) == " " ) {
		while( substring(text,i+1,1) == " " ) { i = i + 1; }
	    }
	    i = i + 1;
	}
	return norm;
    }

    global define create_sambaconf(map sectglobal) ``{
	string cf = SCR::Read(.target.string, Openteam::sambaconf);
	list cflist = splitstring(cf,"\n");
	
	map smbconf = $[];
	string section = "";
	foreach(`line, cflist, ``{
	    if( regexpmatch(line, "^\\[.*" ) ) {
		section = deletechars(line,"[]");
		smbconf[section] = $[];
	    } else {
		if( section != "" ) {
		    string key = regexpsub(line,
					   "^[[:space:]]*([^=]*)[[:space:]]+=[[:space:]]+(.*)",
					   "\\1");
		    key = normalize(key);
		    string val = regexpsub(line,
					   "^[[:space:]]*([^=]*)[[:space:]]+=[[:space:]]+(.*)",
					   "\\2");
		    if( key != nil && val != nil ) {
			y2milestone("[%1]:<%2> = <%3>",section,key,val);
			smbconf[section,key] = val;
		    }
		}
	    }
	});

	foreach(`key, `val, sectglobal, ``{
	    smbconf["global",key] = val;
	});

	cf = "[global]\n";
	foreach(`key, `val, smbconf["global"]:$[], ``{
	    cf = cf + "   " + key + " = " + val + "\n";
	});
	
	foreach(`sect, `smap, smbconf, ``{
	    if( sect != "global" ) {
		cf = cf + "[" + sect + "]\n";
		foreach(`key, `val, smap, ``{
		    cf = cf + "   " + key + " = " + val + "\n";
		});
	    }
	});

	SCR::Write (.target.string, Openteam::sambaconf, cf);
    }
    
    global define create_dhcpdconf() ``{
	string cf = "";

	string fromip = "";
	string toip   = "";
	cnt = 0;
	while( cnt < class ) {
	    fromip = fromip + Openteam::localip[cnt]:"0" + ".";
	    toip = toip + Openteam::localip[cnt]:"0" + ".";
	    cnt = cnt + 1;
	}

	cnt = 0;
	while( cnt < 3 - class ) {
	    fromip = fromip + "0.";
	    toip = toip + "254.";
	    cnt = cnt + 1;
	}

	y2milestone("FROMIP=%1", fromip);
	y2milestone("TOIP=%1",   toip);
	
	
	cf = cf + "option domain-name \"" + Openteam::domain + "\";\n";
	cf = cf + "option domain-name-servers " + mergestring(Openteam::localip,".") + ";\n";
	cf = cf + "option subnet-mask " + mergestring(Openteam::netmask,".") + ";\n";
	cf = cf + "option broadcast-address " + mergestring(Openteam::broadcast,".") + ";\n";
	cf = cf + "option routers " + mergestring(Openteam::gateway,".") + ";\n";
	cf = cf + "option lpr-servers " + mergestring(Openteam::localip,".") + ";\n";
	cf = cf + "option ntp-servers " + mergestring(Openteam::localip,".") + ";\n";
	cf = cf + "option netbios-node-type 8;\n";
	cf = cf + "option netbios-name-servers " + mergestring(Openteam::localip,".") + ";\n";
	cf = cf + "option netbios-dd-server " + mergestring(Openteam::localip,".") + ";\n";
	cf = cf + "option netbios-scope \"\";\n";
	cf = cf + "option ntp-servers " + mergestring(Openteam::localip,".") + ";\n";
	cf = cf + "option ntp-servers " + mergestring(Openteam::localip,".") + ";\n";
	cf = cf + "option ntp-servers " + mergestring(Openteam::localip,".") + ";\n";
	cf = cf + "
ddns-update-style none;
authoritative;
default-lease-time 604800;
max-lease-time 604800;
";
	cf = cf + "subnet " + mergestring(netaddr,".") +
	    " netmask " + mergestring(Openteam::netmask, ".") + " {\n";
	cf = cf + "   range dynamic-bootp " + Openteam::dhcpfrom + " " + Openteam::dhcpto + ";\n";
	cf = cf + "
   # Win95 pre-OSR2 does not work without broadcast
   if option vendor-class-identifier = \"MSFT 95\" {
      always-broadcast on;
   }
}
";

	SCR::Write (.target.string, Openteam::dhcpdconf, cf);
    }

    /*
     * Create Nameserver setup with db files
     * Parameters:
     *
     * serial:   initial serialnumber of NS (yyyyMMDDRR)
     *
     */
    global define create_nssetup(string serial) ``{
	string ns      = "";
	string nsldif  = "";
	string ipaddr  = mergestring(Openteam::localip, ".");
	string revnet = "";
	string inaddr = "";
	integer i = 0;
	integer cnt = 0;
	list tmp    = [];

	////////////////////////////////////////////////////////////////////////////////
	// NS Forward mapping
	////////////////////////////////////////////////////////////////////////////////

	ns = "$TTL 172800\n";
	ns = ns + sformat("@\tIN\tSOA\t%1. postmaster.%1. (\n", Openteam::fqhn);
	ns = ns + sformat("\t\t\t%1\t; serial #YYMMDDRevision", serial);
	ns = ns +
	    "
\t\t\t8H\t; refresh every 8 hours
\t\t\t2H\t; retry every 2 hours
\t\t\t1W\t; expire after one week
\t\t\t1D)\t; minimum TTL

";
	ns = ns + sformat("\tIN\tNS\t%1.\n\n", Openteam::fqhn);
	ns = ns + sformat("\tIN\tA\t%1\n", ipaddr);
	ns = ns + sformat("\tIN\tMX 10\t%1.\n\n", Openteam::fqhn);
	ns = ns + sformat("%1\tIN\tA\t%2\n",
			  select( splitstring(Openteam::fqhn, "."), 0, ""),
			  ipaddr);

	SCR::Write(.target.string, Openteam::nameddir + Openteam::domain + ".zone", ns);

	////////////////////////////////////////////////////////////////////////////////
	// NS Reverse mapping
	////////////////////////////////////////////////////////////////////////////////

        string nmsub = "";
	// count number of seros in netmask
	foreach(`nmsub, Openteam::netmask, ``{
	    if( nmsub == "0" )
		cnt = cnt + 1;
	});
	
	y2milestone("CNT=%1", cnt);


	// create inaddr-arpa address
	tmp = [];
	i = 4 - cnt;
	while( i > 0 ) {
	    //tmp = add(tmp, select(Openteam::localip, (i - 1), 0 ));
	    tmp = add(tmp, Openteam::localip[i - 1]:"0");
	    i = i - 1;
	}

	inaddr = mergestring(tmp, ".") + ".IN-ADDR.ARPA";

	// create relevant parts of reverse Address of own ip
	tmp = [];
	i = 0;
	while( i < cnt ) {
	    //tmp = add(tmp, select(Openteam::localip, (4 - i - 1), 0 ));
	    tmp = add(tmp, Openteam::localip[4 - i - 1]:"0");
	    i = i + 1;
	}

	revnet = mergestring(tmp, ".");

	y2milestone("REVNET=%1", revnet);

	ns = "$TTL 172800\n";
	ns = ns + sformat("@\tIN\tSOA\t%1. postmaster.%1. (\n", Openteam::fqhn);
	ns = ns + sformat("\t\t\t%1\t; serial #YYMMDDRevision", serial);
	ns = ns +
	    "
\t\t\t8H\t; refresh every 8 hours
\t\t\t2H\t; retry every 2 hours
\t\t\t1W\t; expire after one week
\t\t\t1D)\t; minimum TTL

";
	ns = ns + sformat("\tIN\tNS\t%1.\n", Openteam::fqhn);
	ns = ns + sformat("%1\tIN\tPTR\t%2.\n", revnet, Openteam::fqhn);

	SCR::Write(.target.string, Openteam::nameddir + inaddr + ".zone", ns);
	
	
	////////////////////////////////////////////////////////////////////////////////
	// named.conf
	////////////////////////////////////////////////////////////////////////////////
	
	
	SCR::Execute(.target.bash,
		     "/bin/cat /etc/named.conf.in > /etc/named.conf; " +
		     "TMPFILE=`/bin/mktemp -q /tmp/y2namedtmp.XXXXXX` || exit 1; " +
		     "/bin/cat<<EOF > $TMPFILE\n" +
		     sformat("zone \"%1\" {\n", Openteam::domain) +
		     "        type master;\n" +
		     sformat("        file \"%1.zone\";\n", Openteam::domain) +
		     "};\n\n" +
		     sformat("zone \"%1\" {\n", inaddr) +
		     "        type master;\n" +
		     sformat("        file \"%1.zone\";\n", inaddr) +
		     "};
EOF
cat $TMPFILE >> /etc/named.conf; rm -f $TMPFILE");
	
	
	//SCR (`Write (.target.string, namedconf, ns));

	// TOP
	nsldif = sformat("dn: o=DNS,%1", Openteam::ldapbase);
	nsldif = nsldif + "
objectClass: top
objectClass: organization
o: DNS

";

	// Forward/Reverse Zone
	nsldif = nsldif + sformat("dn: relativeDomainName=@,o=DNS,%1", Openteam::ldapbase);
	nsldif = nsldif + "
objectClass: top
objectClass: dNSZone
relativeDomainName: @
";
	nsldif = nsldif + sformat("zoneName: %1\n", Openteam::domain);
	nsldif = nsldif + sformat("zoneName: %1\n", inaddr);
	nsldif = nsldif + "dNSTTL: 172800\n";
	nsldif = nsldif + sformat("sOARecord: %1. postmaster.%1. %2 8H 2H 1W 1D\n",
				  Openteam::fqhn, serial);
	nsldif = nsldif + sformat("nSRecord: %1.\n", Openteam::fqhn);
	nsldif = nsldif + sformat("mXRecord: 10 %1.\n", Openteam::fqhn);
	nsldif = nsldif + sformat("aRecord: %1\n\n", ipaddr);

	// forward host
	nsldif = nsldif + sformat("dn: relativeDomainName=%1,o=DNS,%2",
				  select( splitstring(Openteam::fqhn, "."), 0, ""), Openteam::ldapbase);
	nsldif = nsldif + "
objectClass: top
objectClass: dNSZone
";
	nsldif = nsldif + sformat("relativeDomainName: %1\n",
				  select( splitstring(Openteam::fqhn, "."), 0, ""));
	nsldif = nsldif + sformat("zoneName: %1\n", Openteam::domain);
	nsldif = nsldif + "dNSTTL: 172800\n";
	nsldif = nsldif + sformat("aRecord: %1\n\n", ipaddr);

	// reverse host
	nsldif = nsldif + sformat("dn: relativeDomainName=%1,o=DNS,%2", revnet, Openteam::ldapbase);
	nsldif = nsldif + "
objectClass: top
objectClass: dNSZone
";
	nsldif = nsldif + sformat("relativeDomainName: %1\n", revnet);
	nsldif = nsldif + sformat("zoneName: %1\n", inaddr);
	nsldif = nsldif + "dNSTTL: 172800\n";
	nsldif = nsldif + sformat("PTRRecord: %1.\n\n", Openteam::fqhn);

	SCR::Write(.target.string, Openteam::dnsldif, nsldif);
    }


    /*
     * Create sldapd.conf (ldap server configuration)
     * Parameters:
     *
     *
     */
    global define create_slapdconf() ``{
	string ldp = "";

	ldp = "#
# See slapd.conf(5) for details on configuration options.
# This file should NOT be world readable.
#
include                /etc/openldap/schema/core.schema
include                /etc/openldap/schema/cosine.schema
include                /etc/openldap/schema/inetorgperson.schema
include                /etc/openldap/schema/nis.schema
include                /etc/openldap/schema/suse-email-server.schema
include                /etc/openldap/schema/dnszone.schema
include                /etc/openldap/schema/samba.schema

# Define global ACLs to disable default read access.
access to * by * read

#
# Check, if entries will match to db
#
schemacheck	on

loglevel	0
sizelimit	1000

pidfile		/var/run/slapd.pid
argsfile	/var/run/slapd.args
password-hash   {crypt}

#allow           tls_2_anon
#TLSCertificateFile    /usr/ssl/certs/cert.pem
#TLSCertificateKeyFile /usr/ssl/certs/skey.pem
#TLSCACertificateFile  /usr/ssl/CA/usedCA.pem

#######################################################################
# ldbm database definitions
#######################################################################

# ******************************* System Backend **********************
database	bdb
directory	/var/lib/ldap
lastmod		on
mode		0600

";

	ldp = ldp + sformat("suffix		%1\n", Openteam::ldapbase);
	ldp = ldp + sformat("rootdn		uid=cyrus,%1\n", Openteam::ldapbase);
	ldp = ldp + sformat("rootpw		{crypt}%1\n", crypt(Openteam::passwd));

	ldp = ldp + "
# ******************************* System Backend **********************

#
# cleartext passwords, especially for the rootdn,
# should be avoid.  See slapd.conf(5) for details.

# Don't put all your energy in a senseless searching
#
index           uid,fn,cn,userpassword,memberuid,gidnumber eq
index           alias,relayClientcert,objectclass,uidnumber eq
index           mailenabled,relativeDomainName,zoneName eq,pres
index           vaddress,mail eq,sub,pres

# Access controll
#

# Private AddressBook
";
	ldp = ldp + sformat("access to dn=\"ou=addr,uid=(.*),%1\"\n", Openteam::ldapbase);
	ldp = ldp + sformat("  by dn=\"uid=$1,%1\" write", Openteam::ldapbase);
	ldp = ldp + "  by * none

# To let PAM authenticate
access to attr=userpassword
  by self write
  by anonymous auth
  by * none

access to attr=shadowLastChange
  by self write
  by * read

# only the Admin is allowed to change the members of the addressadmins group
";

	ldp = ldp + sformat("access to dn.base=\"cn=AddressAdmins,o=AddressBook,%1\"", Openteam::ldapbase);
	ldp = ldp + "
  by users read
  by * none
	
# only the members of the AddressAdmins group are allowed to write to the 
# Public Address Book
";

	ldp = ldp + sformat("access to dn.subtree=\"o=AddressBook,%1\"\n",Openteam::ldapbase);
	ldp = ldp + sformat("  by group=\"cn=AddressAdmins,o=AddressBook,%1\" write",Openteam::ldapbase);
	ldp = ldp + "
  by users read
  by * none

# handle write access to the personal data (system address book) 
# - first look at the OpenLDAPaci attribute
# - if that doesn't exist or the user-dn is not in the subject clause,
#   give write access to the owner of the entry and read acces to anyone else
access to attr=c,cn,telephoneNumber,facsimileTelephoneNumber,pager,title,givenname,sn,l,description,mail,street,postalCode,st,homePhone,ou,initials,mobile,labeledURI,preferredLanguage,entry
  by aci write break
  by self write
  by * read
# if the above break statement is reached add read access for everyone
access to attr=c,cn,telephoneNumber,facsimileTelephoneNumber,pager,title,givenname,sn,l,description,mail,street,postalCode,st,homePhone,ou,initials,mobile,labeledURI,preferredLanguage,entry
  by * +rsc

access to attr=comFireTaskDays,comFireAppointmentDays
  by self write
  by * none
";

	SCR (`Write (.target.string, Openteam::slapdconf, ldp));
    }

    global define write_postconf(map params) ``{
	foreach(`key, `value, params, ``{
	    string cmd = sformat("/usr/sbin/postconf -e '%1=%2'", key, value);
	    if( SCR::Execute(.target.bash, cmd) != 0 ) {
		y2warning("error writing main.cf");
	    }
	});
    }

    /*
     * Append LDAP lookup tables to /etc/postfix/main.cf (postfix configuration)
     * Parameters:
     *
     *
     */
    global define append_ldaptables() ``{
	string cf = SCR::Read(.target.string, Openteam::maincf );

	cf = cf + "
# alias database for SuSE Linux Open Team Server
ldapaliases_server_host = localhost
ldapaliases_server_port = 389
ldapaliases_bind = no
ldapaliases_timeout = 20
";

	cf = cf + sformat("ldapaliases_search_base = %1", Openteam::ldapbase);
	cf = cf + "
ldapaliases_query_filter = (|(alias=%s)(&(fn=%s)(objectclass=SuSEIMAPFolderObject)))
ldapaliases_result_attribute = uid,mailDeliveryProgram,deliverToUID
ldapaliases_scope = one

# virtual user database for SuSE Linux Open Team Server
ldapvuser_server_host = localhost
ldapvuser_server_port = 389
ldapvuser_bind = no
ldapvuser_timeout = 20
";

	cf = cf + sformat("ldapvuser_search_base = %1", Openteam::ldapbase);
	cf = cf + "
ldapvuser_query_filter = (&(objectclass=SuSEVirtUserObject)(vaddress=%s))
ldapvuser_result_attribute = uid,mailDeliveryProgram
ldapvuser_scope = one

# this is used to enable/disable mail reception
ldapmailenab_server_host = localhost
ldapmailenab_server_port = 389
ldapmailenab_bind = no
ldapmailenab_timeout = 20
";

	cf = cf + sformat("ldapmailenab_search_base = %1", Openteam::ldapbase);
	cf = cf + "
ldapmailenab_query_filter = (reject=%s)
ldapmailenab_result_attribute = mailenabled
ldapmailenab_scope = one

# this is used for client certificate based relaying
ldaprelcert_server_host = localhost
ldaprelcert_server_port = 389
ldaprelcert_bind = no
ldaprelcert_timeout = 20
";
	cf = cf + sformat("ldaprelcert_search_base = %1", Openteam::ldapbase);
	cf = cf + "
ldaprelcert_query_filter = (relayClientcert=%s)
ldaprelcert_result_attribute = uid
ldaprelcert_scope = one
";
	SCR::Write(.target.string, Openteam::maincf, cf);
    }


    /*
     * Generate base ldif for LDAP Server
     * Parameters:
     *
     *
     */
    global define genldif() ``{
      string ldif ="";

      // TOP DN entry
      ldif = sformat("dn: %1", Openteam::ldapbase);
      ldif = ldif + "
objectclass: top
objectclass: dcObject
objectclass: domain
";
      ldif = ldif + sformat("dc: %1\n\n", Openteam::fqhnlist[1]:"");

      // Admin enty
      // ****  NOTE about SuSEVirtUserObject: ****
      // We need this to enforce slapd to create an index of vaddress.
      // If we don't do it, a search would be to slow.
      // We will remove it after creating the base entries with ldapadd in
      // imap_step2.ycp
      ldif = ldif + sformat("dn: uid=cyrus,%1",Openteam::ldapbase);
      ldif = ldif + "
objectclass: top
objectclass: person
objectclass: inetOrgPerson
objectclass: SuSEeMailObject
objectClass: SuSEPopAccount
objectClass: SuSEVirtUserObject
vaddress: info@foo.bar
mailenabled: OK
";
      ldif = ldif + sformat("mailDomain: %1\n", Openteam::domain);
      ldif = ldif + sformat("mail: cyrus@%1\n", Openteam::domain);
      ldif = ldif + sformat("preferredLanguage: %1\n", Openteam::lang);
      ldif = ldif + sformat("c: %1", Openteam::ccode);
      ldif = ldif + "
uid: cyrus
cn: cyrus
sn: cyrus
";
      ldif = ldif + sformat("o: %1\n", Openteam::ldaporg);
      ldif = ldif + sformat("imapServer: %1\n", Openteam::fqhn);
      ldif = ldif + sformat("smtpServer: %1", Openteam::fqhn);
      ldif = ldif + "
imapPort: 143
sievePort: 2000

";

      // Default primary Group
      ldif = ldif + sformat("dn: cn=users,%1",Openteam::ldapbase);
      ldif = ldif + "
objectclass: top
objectclass: posixGroup
cn: users
gidnumber: 100
userpassword: {crypt}*

";

      // Default Shared Folder
      ldif = ldif + sformat("dn: fn=users,%1",Openteam::ldapbase);
      ldif = ldif + "
objectclass: top
objectclass: SuSEIMAPFolderObject
fn: users
mailenabled: REJECT

";

      // Public AddressBook root object
      ldif = ldif + sformat("dn: o=AddressBook,%1",Openteam::ldapbase);
      ldif = ldif + "
objectclass: top
objectclass: organization
o: AddressBook

";

      // Public AddressBook Admin Group
      ldif = ldif + sformat("dn: cn=AddressAdmins,o=AddressBook,%1",Openteam::ldapbase);
      ldif = ldif + "
objectclass: top
objectclass: groupofNames
cn: AddressAdmins
";
      ldif = ldif + sformat("member: uid=cyrus,%1\n",Openteam::ldapbase);

      SCR (`Write (.target.string, Openteam::baseldif, ldif));
    }

/* EOF */
}
